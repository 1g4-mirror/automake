#! /usr/bin/perl
# Generate tests-deps.am.

# Copyright (C) 2011 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use warnings FATAL => "all";
use strict;
use File::Basename ();

my $me = File::Basename::basename $0;

# For use in VPATH builds.
my $srcdir = ".";

#--------------------------------------------------------------------------

sub line_match ($$)
{
  my ($re, $file) = (shift, shift);
  open (FH, "<$file") or open (FH, "<$srcdir/$file")
    or die "$me: cannot open file `$file': $!\n";
  my $ret = 0;
  while (defined (my $line = <FH>))
    {
      if ($line =~ $re)
        {
          $ret = 1;
          last;
        }
    }
  close FH or die "$me: cannot close file `$file': $!\n";
  return $ret;
}

sub get_list_of_tests ()
{
  my $make = defined $ENV{MAKE} ? $ENV{MAKE} : "make";
  # Unset MAKEFLAGS, for when we are called from make itself.
  my $cmd = "MAKEFLAGS= && unset MAKEFLAGS && cd '$srcdir' && "
            . "$make -s -f list-of-tests.mk print-list-of-tests";
  my @tests_list = split /\s+/, `$cmd`;
  die "$me: cannot get list of tests\n" unless $? == 0 && @tests_list;
  my $ok = 1;
  foreach my $test (@tests_list)
    {
      next if -f $test || -f "$srcdir/$test";
      warn "$me: test `$test' not found\n";
      $ok = 0;
    }
  die "$me: some test scripts not found\n" if !$ok;
  return @tests_list;
}

sub parse_options (@)
{
  use Getopt::Long qw/GetOptions/;
  local @ARGV = @_;
  GetOptions ('srcdir=s' => \$srcdir) or die "$me: usage error\n";
  die "$me: too many arguments\n" if @ARGV > 0;
  die "$me: srcdir `$srcdir': not a directory\n" unless -d $srcdir;
}

#--------------------------------------------------------------------------

my %deps_extractor =
  (
    use_trivial_test_driver =>
      {
        line_matcher => qr/\btrivial-test-driver\b/,
        dist_prereqs => "trivial-test-driver",
      },
    check_testsuite_summary =>
      {
        line_matcher => qr/\btestsuite-summary-checks\.sh\b/,
        dist_prereqs => "testsuite-summary-checks.sh",
      },
    extract_testsuite_summary =>
      {
        line_matcher => qr/\bextract-testsuite-summary\b/,
        dist_prereqs => "extract-testsuite-summary",
      },
    check_tap_testsuite_summary =>
      {
        line_matcher => qr/\btap-summary-aux\.sh\b/,
        dist_prereqs => "tap-summary-aux.sh",
      },
    is_test_on_tap_with_common_setup =>
      {
        line_matcher => qr/\btap-setup\.sh\b/,
        dist_prereqs => "tap-setup.sh",
        nodist_prereqs => "tap-common-setup.log",
      },
  );

#--------------------------------------------------------------------------

parse_options @ARGV;

my @tests = get_list_of_tests;

print "## Generated by $me.  DO NOT EDIT BY HAND!\n";

while (my ($k, $x) = each %deps_extractor)
  {
    my $dist_prereqs = $x->{dist_prereqs} || "";
    my $nodist_prereqs = $x->{nodist_prereqs} || "";
    my @logs = grep { line_match $x->{line_matcher}, $_ } @tests;
    map { s/\.[^.]*$//; s/$/\.log/; } @logs;
    print "\n## Added by deps-extracting key `$k'.\n";
    print "EXTRA_DIST += $dist_prereqs\n";
    map { print "$_: $dist_prereqs $nodist_prereqs\n" } @logs;
  }

__END__

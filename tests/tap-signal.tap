#! /bin/sh
# Copyright (C) 2011 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TAP support:
#  - a test script terminated by a signal causes an hard error

am_parallel_tests=yes
. ./defs || Exit 1

plan_ 10

cat > Makefile.am << END
TEST_LOG_COMPILER = $PERL -w
## Will be updated later.
TESTS =
END

all_signals='1 2 3 9 13 15'
blocked_signals=''
for sig in $all_signals; do
  # Ignore blocked signals
  if is_blocked_signal $sig; then
    blocked_signals="$blocked_signals $sig"
    continue
  fi
  # Write the dummy test scripts in perl, not as shell scripts, to work
  # around unportabilities in the handling of signals (in fact, even
  # with bash, the older script were unable to properly deliver a SIGQUIT
  # to themselves consistently).  The shebang is dummy here, as we prefer
  # to rely on the definition of TEST_LOG_COMPILER instead.
  unindent > signal-$sig.test <<END
    #! perl
    # We need autoflush to avoid losing output, which could cause spurious
    # "no test plan seen" in the TAP driver.
    BEGIN { $| = 1 }
    use warnings FATAL => "all";
    print "1..1\\n";
    print "ok 1\\n";
    kill $sig, \$\$;
    print "Bail out! \$0 not killed?\\n";
END
  echo TESTS += signal-$sig.test >> Makefile.am
done
results_count=`ls *.test | wc -l | tr -d "$tab$sp"`

chmod a+x *.test

. "$testsrcdir"/tap-setup.sh || fatal_ "sourcing tap-setup.sh"

# Solaris /bin/sh, when killed with a SIGTERM, SIGQUIT or SIGINT signal,
# can end up exiting with exit status 208, instead of leaving the correct
# wide exit status to the parent.  See:
#   <http://dbaspot.com/shell/396118-bourne-shell-exit-code-term.html>
# We need to detect and work around this incompatibility.

have_solaris_bug=no
for sig in 2 3 15; do
  if /bin/sh -c "kill -$sig \$\$"; then
    warn_ "/bin/sh cannot kill itself with signal $sig"
  elif test $? -eq 208; then
    warn_ "/bin/sh exits with status 208 upon some signals (Solaris?)"
    warn_ "we will try to work around this bug"
    have_solaris_bug=yes
    break
  fi
done

signal_caught ()
{
  numeric=$1
  case $numeric in
     1) symbolic=HUP;;
     2) symbolic=INT;;
     3) symbolic=QUIT;;
     9) symbolic=KILL;;
    13) symbolic=PIPE;;
    15) symbolic=TERM;;
     *) fatal_ "unexpected signal number '$numeric'"
  esac
  sig_re="((SIG)?$symbolic|$numeric)"
  wbound_re="($|[^a-zA-Z0-9_-])"
  pfx_re="^ERROR: signal-$numeric\\.test"
  case $am_tap_implementation in
    perl) rx="$pfx_re - terminated by signal $sig_re$";;
    shell) rx="$pfx_re .*terminated by signal $sig_re$wbound_re";;
    *) fatal_ "invalid \$am_tap_implementation '$am_tap_implementation'";;
  esac
  directive='' reason=''
  case $have_solaris_bug,$symbolic in
    yes,INT|yes,TERM|yes,QUIT) directive=TODO reason="Solaris /bin/sh bug";;
  esac
  case " $blocked_signals " in
    *" $numeric "*)
      reason="SIG$symbolic is blocked" directive=SKIP result=ok;;
    *)
      LC_ALL=C $EGREP "$rx" stdout && result='ok' || result='not ok';;
  esac
  result_ "$result" -D "$directive" -r "$reason" \
          "TAP driver catch test termination by signal SIG$symbolic"
}

command_ok_ '"make check" fails' eval 'not $MAKE check >stdout'
cat stdout # For debugging.

command_ok_ "count of test results" count_test_results \
  total=`expr $results_count '*' 2` \
  pass=$results_count error=$results_count \
  fail=0 xpass=0 xfail=0 skip=0

for sig in $all_signals; do
  signal_caught $sig
done

echo 'TEST_LOG_DRIVER_FLAGS = --ignore-exit' >> Makefile

command_ok_ '"make check" passes [--ignore-exit]' eval '$MAKE check >stdout'
cat stdout # For debugging.

command_ok_ "count of test results [--ignore-exit]" count_test_results \
  total=$results_count pass=$results_count \
  fail=0 xpass=0 xfail=0 skip=0 error=0

:

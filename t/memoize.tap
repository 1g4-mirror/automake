#! /bin/sh
# Copyright (C) 2012 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test Automake-provided memoization for make variables.

am_create_testdir=empty
. test-init.sh

plan_ 17

ocwd=$(pwd) || fatal_ "couldn't get current working directory"

# Filter out Automake comments.
grep -v '^##' "$am_amdir"/header-vars.mk > defn.mk \
  || fatal_ "fetching makefile fragment headers-vars.am"

T ()
{
  tcount=$(($tcount + 1))
  mkdir $tcount.d
  cd $tcount.d
  echo include ../defn.mk > Makefile
  cat >> Makefile
  command_ok_ "$1" "$MAKE" test
  cd ..
}
tcount=0

#---------------------------------------------------------------------------

## NOTE: Every repeated check in the recipes of the tests below is
##       really intended!

#---------------------------------------------------------------------------

T "basic usage" <<'END'

foo = $(call am.memoize,foo,ok)

test:
	test '$(foo)' = ok
	test '$(foo)' = ok
END

#---------------------------------------------------------------------------

T "variables expanding to blanks only (1)" <<'END'

foo = $(call am.memoize,foo,$(am.chars.empty) )

test:
	test '$(foo)' = ' '
	test '$(foo)' = ' '
END

#---------------------------------------------------------------------------

T "variables expanding to blanks only (2)" <<END

blank = \$(am.chars.empty) $tab$tab   \$(am.chars.empty)
foo = \$(call am.memoize,foo,\$(blank))

test:
	test '\$(foo)' = ' $tab$tab   '
	test '\$(foo)' = ' $tab$tab   '
END

#---------------------------------------------------------------------------

# $var will be 3 * 2^12 ~ 12000 characters long.
var=foo
for i in 1 2 3 4 5 6 7 8 9 10 11 12; do
  var=$var$var
  # Temporary disable shell traces, because otherwise the result '.log' file
  # would end up having too long lines that could confuse inferior awk
  # implementations (e.g., Solaris 10 /usr/xpg4/bin/awk), which would cause
  # spurious errors in our test harness.
  set +x
done
set -x # Re-enable shell traces.

T "very long variable name" <<END

$var = \$(call am.memoize,$var,foo)

test:
	# Why we silence this?
	# See comment above about overly long lines in '.log' file.
	@echo test1; test '\$($var)' = foo
	@echo test2; test '\$($var)' = foo
END

#---------------------------------------------------------------------------

# $var and $val will be 3 * 2^12 ~ 12000 characters long.
var=foo
val=bar
for i in 1 2 3 4 5 6 7 8 9 10 11 12; do
  var=$var$var
  val=$val$val
  # Temporary disable shell traces.  See comment above for a rationale.
  set +x
done
set -x # Re-enable shell traces.

T "very long variable name with long content" <<END

$var = \$(call am.memoize,$var,$val)

test:
	# Why we silence this?
	# See comment above about overly long lines in '.log' file.
	@echo test1; test '\$($var)' = '$val'
	@echo test2; test '\$($var)' = '$val'
END

#---------------------------------------------------------------------------

T "memoize indirect recursive variable expansion" <<'END'

foo = $(call am.memoize,foo,$(indir))

## This is delibrately placed after the memoize call.
indir = zardoz

test:
	test '$(foo)' = zardoz
	test '$(foo)' = zardoz
END

#---------------------------------------------------------------------------

T "memoize indirect immediate variable expansion" <<'END'

foo = $(call am.memoize,foo,$(indir))

## This is delibrately placed after the memoize call.
indir := blob

test:
	test '$(foo)' = blob
	test '$(foo)' = blob
END

#---------------------------------------------------------------------------

T "memoize function call (containing builtin calls)" <<'END'

my_func = $(firstword $(sort $(1)))
foo = $(call am.memoize,foo,$(call my_func, 6 3 1 7))

test:
	test '$(foo)' = 1
	test '$(foo)' = 1
END

#---------------------------------------------------------------------------

T "expanded as function argument" <<'END'

foo = $(call am.memoize,foo,bar)
func = ::$(0)::$(1)::

test:
	test '$(call func,$(foo))' = ::func::bar::
	test '$(foo)' = bar
	# Once more.
	test '$(call func,$(foo))' = ::func::bar::
END

#---------------------------------------------------------------------------

T "expanded as function argument (trickier)" <<'END'

foo = $(call am.memoize,foo,zardoz)
indir_func = ::$($1)::

test:
	test '$(call indir_func,foo)' = ::zardoz::
	test '$(foo)' = zardoz
	# Once more.
	test '$(call indir_func,foo)' = ::zardoz::
END

#---------------------------------------------------------------------------

T "expanded into another memoized variable" <<'END'

foo = $(call am.memoize,foo,one $(bar))
bar = $(call am.memoize,bar,two $(baz))
baz = $(call am.memoize,baz,$(sort 4 3))

test:
	test '$(foo)' = 'one two 3 4'
	test '$(bar)' = 'two 3 4'
END

#---------------------------------------------------------------------------

T "memoization actually takes place (1)" <<'END'

indir := ok
foo = $(call am.memoize,foo,$(indir))
expand-it := $(foo)
override indir := ko

test:
	test '$(foo)' = ok
	test '$(indir)' = ko
END

#---------------------------------------------------------------------------

T "memoization actually takes place (2)" <<'END'

indir := ok
expand = $(eval expanded-to := $$($1))
foo = $(call am.memoize,foo,$(indir))
$(call expand,foo)
override indir := ko

test:
	test '$(foo)' = ok
	test '$(indir)' = ko
	test '$(expanded-to)' = ok
END

#---------------------------------------------------------------------------

T "memoization actually takes place (3)" <<'END'

foo1 = $(call am.memoize,foo1,$(shell test -f x && echo "+"))
foo2 = $(call am.memoize,foo2,$(shell test -f y || echo "-"))

test: one two
two: one
.PHONY: one two one-setup two-setup
one-setup:
	rm -f y
	echo dummy > x
one: one-setup
	test -f x
	test '$(foo1)' = '+'
	test ! -f y
	test '$(foo2)' = '-'
two-setup:
	rm -f x
	echo dummy > y
two: two-setup
	test ! -f x
	test '$(foo1)' = '+'
	test -f y
	test '$(foo2)' = '-'
END

#---------------------------------------------------------------------------


T "definition on multiple lines" <<'END'

foo = $(call am.memoize,foo,a \
  b \
  c \
  \
  d)

test:
	test '$(foo)' = 'a b c d'
	test '$(foo)' = 'a b c d'
END

#---------------------------------------------------------------------------

# This usage has been known to cause problems with GNU make <= 3.82,
# tickling this bug:
# <http://lists.gnu.org/archive/html/bug-make/2012-05/msg00013.html>
# <https://savannah.gnu.org/patch/?7534>

T "known GNU make issue (https://savannah.gnu.org/patch/?7534)" <<'END'

setup := $(shell mkdir -p t/pm && : > t/pm/Cond2.pl)

TESTS = $(wildcard t/pm/Cond2.pl)
am.test-suite.test-bases = $(call am.memoize,am.test-suite.test-bases,$(TESTS))

test:
	test '$(am.test-suite.test-bases)' = 't/pm/Cond2.pl'
END

#---------------------------------------------------------------------------

# Try memoization with variables having a very long content.  Our first
# (unpublished) memoization implementation didn't work in that case -- it
# triggered errors like "*** unterminated variable reference.  Stop" when
# the content's length because big enough.

line='dummy abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ='

# About 1 million lines.
echo "  $line \\" > t
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
  cat t t > t1
  mv -f t1 t
done

echo "list = \$(call am.memoize,list,$line \\" >> big.mk
cat t >> big.mk
echo "  $line)" >> big.mk

cat >> big.mk << 'END'
test:
	test x'$(word  1, $(list))' = x'dummy'
	test x'$(word  3, $(list))' = x'='
	test x'$(word 31, $(list))' = x'dummy'
	test x'$(word 93, $(list))' = x'='
END

T "very long variable content" < big.mk

#---------------------------------------------------------------------------

:

#! /bin/sh
# ylwrap - wrapper for lex/yacc invocations.

scriptversion=2011-05-05.12; # UTC

# Copyright (C) 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005,
# 2007, 2009, 2010, 2011 Free Software Foundation, Inc.
#
# Originally written by Tom Tromey <tromey@cygnus.com>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# This file is maintained in Automake, please report
# bugs to <bug-automake@gnu.org> or send patches to
# <automake-patches@gnu.org>.

usage_error ()
{
  echo "$0: $*" >&2
  echo "Try \`$0 --help' for more information." >&2
  exit 2
}

# Escape (most) sed metacharacters in the given string, so that it can
# be used as a literal string in a sed match or substitute command.
quote_for_sed ()
{
  printf '%s\n' "$1" | sed -e 's/[].[^$\\*|]/\\&/g'
}

# For system that lacks a dirname command, we simulate it with sed.
dirname_ ()
{
  dirname "$1" 2>/dev/null \
    || printf '%s\n' "$1" | sed -e 's,\([\\/]\)[^\\/]*$,\1,'
}

# Turn the given string into a suitable C preprocessor symbol.
tr_cpp ()
{
  printf '%s\n' "$1" \
    | sed -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' \
          -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'
}

# Since DOS filename conventions don't allow two dots, the DOS version
# of Bison writes out y_tab.c instead of y.tab.c and y_tab.h instead of
# y.tab.h.  Test to see if this is the case, ans set the default names
# of the yacc output files accordingly.
# This subroutine sets the global variables `$y_tab_c', `$y_tab_h' and
# `$y_output'.
set_yacc_filenames ()
{
  test $wrapped = yacc || return 0
  if test -f y_tab.c || test -f y_tab.h; then
    y_tab_c=y_tab.c
    y_tab_h=y_tab.h
  else
    y_tab_c=y.tab.c
    y_tab_h=y.tab.h
  fi
  y_output=y.output
}

# Usage: handle_renaming FROM TARGET
handle_renaming ()
{
  from=$1
  target=$2
  if test ! -f $tempdir/$from; then
    echo "ylwrap: expected file \`$from' not found" >&2
    ret=1
    return
  fi

  # Edit out `#line' or `#' directives.
  #
  # We don't want the resulting debug information to point at
  # an absolute srcdir; it is better for it to just mention the
  # .y file with no path.
  #
  # We want to use the real output file name, not yy.lex.c for
  # instance.
  #
  # We want the include guards to be adjusted too.
  # TODO: This include guards seems not to be generated anymore
  # by newer bison versions (at least starting from 1.875; they
  # were still generated in version 1.75, though).  Also, BSD and
  # Solaris yacc seems not to generate such include guards either.
  # So, how much is this code still relevant today?
  FROM=`tr_cpp "$from"`
  TARGET=`tr_cpp "$target"`

  sed -e "/^#/!b" -e "s,$input_rx,," -e "s,$from,$target," \
      -e "s,$FROM,$TARGET," $tempdir/"$from" >"$target" || ret=$?
}

move_if_change ()
{
  src=$1
  dest=$2
  if test -f "$dest" && cmp -s "$src" "$dest"; then
    echo "$dest is unchanged"
    rm -f "$src"
  else
    echo "updating $dest"
    mv -f "$src" "$dest"
  fi
}

test $# -gt 0 || usage_error "missing argument"

case "$1" in
  --help)
    cat <<\EOF
ylwrap: Wrapper for lex/yacc invocations, renaming files as desired.

Usage:
  ylwrap {--help|--version}
or:
  ylwrap --yacc YACC-EXTENSION INPUT [--] PROGRAM [ARGS]...
or:
  ylwrap --lex LEX-OUTPUT-ROOT INPUT OUTPUT [--] PROGRAM [ARGS]...

Report bugs to <bug-automake@gnu.org>.
EOF
    exit $?
    ;;
  --version)
    echo "ylwrap $scriptversion"
    exit $?
    ;;
  --yacc)
    wrapped=yacc
    shift
    case $# in
      0) usage_error "missing yacc extension";;
      1) usage_error "missing input file";;
      2) usage_error "missing output file";;
    esac
    y_ext=`expr x"$1" : x'\.\(.*\)'`
    input=$2
    output=$3
    shift 3
    ;;
  --lex)
    wrapped=lex
    shift
    case $# in
      0) usage_error "missing lex output root";;
      1) usage_error "missing input file";;
      2) usage_error "missing output file";;
    esac
    lex_output_root=$1
    input=$2
    output=$3
    shift 3
    ;;
  -*)
    usage_error "invalid option '$1'"
    ;;
  *)
    break
    ;;
esac

test -n "$wrapped" || usage_error "no operation mode specified"

if test x"$1" = x"--"; then
  shift
fi

test $# -gt 0 || usage_error "missing program to run"
prog="$1"
shift

ocwd=`pwd` || exit 1

# We are going to run yacc from another directory, so make relative
# paths in $prog and $input absolute as fit.
case $prog in
  [\\/]* | ?:[\\/]*) ;;
  # If $prog does not contain any component directory, it will be
  # looked up in $PATH, so don't modify it.
  *[\\/]*) prog=$ocwd/$prog ;;
esac

case $input in
  [\\/]* | ?:[\\/]*) ;;
  *) input=$ocwd/$input ;;
esac

# FIXME: add hostname here for parallel makes that run commands on
# other machines.  But that might take us over the 14-char limit.
tempdir=ylwrap$$
do_exit="cd '$ocwd' && rm -rf $tempdir; (exit \$ret); exit \$ret"
# The only signals which are portably trappable are 1 (SIGHUP),
# 2 (SIGINT), 13 (SIGPIPE) and 15 (SIGTERM).
trap "ret=129; $do_exit" 1
trap "ret=130; $do_exit" 2
trap "ret=141; $do_exit" 13
trap "ret=143; $do_exit" 15
mkdir $tempdir || exit 1

cd $tempdir || exit 1
case $# in
  0) "$prog" "$input" ;;
  *) "$prog" "$@" "$input" ;;
esac
ret=$?
set_yacc_filenames
cd "$ocwd" || exit 1

test $ret -eq 0 || eval "$do_exit"

# The directory holding the input.
input_dir=`dirname_ "$input"`
# Quote $input_dir so we can use it in a regexp.
input_rx=`quote_for_sed "$input_dir"`

case $wrapped in
  yacc)
    c_ext=`echo $y_ext | tr 'y' 'c'`
    h_ext=`echo $y_ext | tr 'y' 'h'`
    output_stem=`echo "$output" | sed "s/\\\\.$c_ext$//"`
    # We do not want to overwrite a header file if it hasn't
    # changed.  This avoid useless recompilations.  However the
    # parser itself should always be updated, because it is the
    # destination of the .y.c rule in the Makefile.
    handle_renaming $y_tab_c $output_stem.$c_ext
    # If the `-d' option is not used, we don't want an error when the
    # header file is "missing".  Similarly, if `-v' is not used, we
    # don't want an error when the `y.output' file is "missing".
    if test -f $tempdir/$y_tab_h; then
      handle_renaming $y_tab_h $tempdir/header.tmp
      move_if_change $tempdir/header.tmp $output_stem.$h_ext
    fi
    if test -f $tempdir/$y_output; then
      handle_renaming $y_output $output_stem.output
    fi
    ;;
  lex)
    handle_renaming $lex_output_root.c $output
    ;;
  *)
    exit 255 # Not reached.
    ;;
esac

eval "$do_exit"

# Local Variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:

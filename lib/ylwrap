#! /bin/sh
# ylwrap - wrapper for lex/yacc invocations.

scriptversion=2011-05-05.12; # UTC

# Copyright (C) 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005,
# 2007, 2009, 2010, 2011 Free Software Foundation, Inc.
#
# Originally written by Tom Tromey <tromey@cygnus.com>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# This file is maintained in Automake, please report
# bugs to <bug-automake@gnu.org> or send patches to
# <automake-patches@gnu.org>.

usage_error ()
{
    echo "$0: $*" >&2
    echo "Try \`$0 --help' for more information." >&2
    exit 2
}

# Escape (most) sed metacharacters in the given string, so that it can
# be used as a literal string in a sed match or substitute command.
quote_for_sed ()
{
  printf '%s\n' "$1" | sed -e 's/[].[^$\\*|]/\\&/g'
}

# For system that lacks a dirname command, we simulate it with sed.
dirname_ ()
{
  dirname "$1" 2>/dev/null \
    || printf '%s\n' "$1" | sed -e 's,\([\\/]\)[^\\/]*$,\1,'
}

# Turn the given string into a suitable C preprocessor symbol.
tr_cpp ()
{
  printf '%s\n' "$1" \
    | sed -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' \
          -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'
}

# Since DOS filename conventions don't allow two dots, the DOS version
# of Bison writes out y_tab.c instead of y.tab.c and y_tab.h instead
# of y.tab.h.  Test to see if this is the case.
# This function might set the global variable `$y_tab_nodot' (meant for
# internal use only), and modify the global variable `$from'.
dos_fix_yacc_filenames ()
{
  test $wrapped = yacc || return 0
  if test -z "$y_tab_nodot"; then
    if test -f y_tab.c || test -f y_tab.h; then
      y_tab_nodot=yes
    else
      y_tab_nodot=no
    fi
  fi
  if test $y_tab_nodot = yes; then
    # Handle y_tab.c and y_tab.h output by DOS
    test $from = y.tab.c && from=y_tab.c
    test $from = y.tab.h && from=y_tab.h
  fi
}

# Usage: handle_renaming FROM TARGET
handle_renaming ()
{
    from=$1
    ofrom=$from
    dos_fix_yacc_filenames
    if test ! -f $from; then
      # When using yacc, if the `-d' option is not used, we don't want an
      # error when the header file is "missing".  Similarly, if `-v' is not
      # used, we don't want an error when the `y.output' file is "missing".
      case $wrapped:$ofrom in
        yacc:y.tab.h|yacc:y.output) ;;
        *)
          echo "ylwrap: expected file \`$from' not found" >&2
          ret=1
          ;;
      esac
      return
    fi

    # If $2 is an absolute path name, then just use that,
    # otherwise prepend `../'.
    case $2 in
      [\\/]* | ?:[\\/]*) target=$2;;
      *) target=../$2;;
    esac

    # We do not want to overwrite a header file if it hasn't
    # changed.  This avoid useless recompilations.  However the
    # parser itself (the first file) should always be updated,
    # because it is the destination of the .y.c rule in the
    # Makefile.  Divert the output of all other files to a temporary
    # file so we can compare them to existing versions.
    if test $wrapped = yacc && test $ofrom = y.tab.h; then
      realtarget=$target
      target=header.tmp
    fi
    # Edit out `#line' or `#' directives.
    #
    # We don't want the resulting debug information to point at
    # an absolute srcdir; it is better for it to just mention the
    # .y file with no path.
    #
    # We want to use the real output file name, not yy.lex.c for
    # instance.
    #
    # We want the include guards to be adjusted too.
    # TODO: This include guards seems not to be generated anymore
    # by newer bison versions (at least starting from 1.875; they
    # were still generated in version 1.75, though).  Also, BSD and
    # Solaris yacc seems not to generate such include guards either.
    # So, how much is this code still relevant today?
    FROM=`tr_cpp "$from"`
    TARGET=`tr_cpp "$2"`

    sed -e "/^#/!b" -e "s,$input_rx,," -e "s,$from,$2," \
        -e "s,$FROM,$TARGET," "$from" >"$target" || ret=$?

    # Check whether header files must be updated.
    if test $wrapped = yacc && test $ofrom = y.tab.h; then
     if test -f "$realtarget" && cmp -s "$realtarget" "$target"; then
       echo "$2" is unchanged
       rm -f "$target"
     else
        echo updating "$2"
        mv -f "$target" "$realtarget"
      fi
    fi
}

test $# -gt 0 || usage_error "missing argument"

case "$1" in
  --help)
    cat <<\EOF
ylwrap: Wrapper for lex/yacc invocations, renaming files as desired.

Usage:
  ylwrap {--help|--version}
or:
  ylwrap --yacc YACC-EXTENSION INPUT [--] PROGRAM [ARGS]...
or:
  ylwrap --lex LEX-OUTPUT-ROOT INPUT OUTPUT [--] PROGRAM [ARGS]...

Report bugs to <bug-automake@gnu.org>.
EOF
    exit $?
    ;;
  --version)
    echo "ylwrap $scriptversion"
    exit $?
    ;;
  --yacc)
    wrapped=yacc
    shift
    case $# in
      0) usage_error "missing yacc extension";;
      1) usage_error "missing input file";;
      2) usage_error "missing output file";;
    esac
    y_ext=`expr x"$1" : x'\.\(.*\)'`
    input=$2
    output=$3
    shift 3
    ;;
  --lex)
    wrapped=lex
    shift
    case $# in
      0) usage_error "missing lex output root";;
      1) usage_error "missing input file";;
      2) usage_error "missing output file";;
    esac
    lex_output_root=$1
    input=$2
    output=$3
    shift 3
    ;;
  -*)
    usage_error "invalid option '$1'"
    ;;
  *)
    break
    ;;
esac

test -n "$wrapped" || usage_error "no operation mode specified"

if test x"$1" = x"--"; then
  shift
fi

test $# -gt 0 || usage_error "missing program to run"
prog="$1"
shift

ocwd=`pwd` || exit 1

# We are going to run yacc from another directory, so make relative
# paths in $prog and $input absolute as fit.
case $prog in
  [\\/]* | ?:[\\/]*) ;;
  # If $prog does not contain any component directory, it will be
  # looked up in $PATH, so don't modify it.
  *[\\/]*) prog=$ocwd/$prog ;;
esac

case $input in
  [\\/]* | ?:[\\/]*) ;;
  *) input=$ocwd/$input ;;
esac

# FIXME: add hostname here for parallel makes that run commands on
# other machines.  But that might take us over the 14-char limit.
dirname=ylwrap$$
do_exit="cd '$ocwd' && rm -rf $dirname; (exit \$ret); exit \$ret"
# The only signals which are portably trappable are 1 (SIGHUP),
# 2 (SIGINT), 13 (SIGPIPE) and 15 (SIGTERM).
trap "ret=129; $do_exit" 1
trap "ret=130; $do_exit" 2
trap "ret=141; $do_exit" 13
trap "ret=143; $do_exit" 15
mkdir $dirname || exit 1
cd $dirname || exit 1

case $# in
  0) "$prog" "$input" ;;
  *) "$prog" "$@" "$input" ;;
esac
ret=$?

test $ret -eq 0 || eval "$do_exit"

# The directory holding the input.
input_dir=`dirname_ "$input"`
# Quote $input_dir so we can use it in a regexp.
input_rx=`quote_for_sed "$input_dir"`

case $wrapped in
  yacc)
    c_ext=`echo $y_ext | tr 'y' 'c'`
    h_ext=`echo $y_ext | tr 'y' 'h'`
    output_stem=`echo "$output" | sed "s/\\\\.$c_ext$//"`
    handle_renaming y.tab.c  $output_stem.$c_ext
    handle_renaming y.tab.h  $output_stem.$h_ext
    handle_renaming y.output $output_stem.output
    ;;
  lex)
    handle_renaming $lex_output_root.c $output
    ;;
  *)
    exit 255 # Not reached.
    ;;
esac

eval "$do_exit"

# Local Variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:

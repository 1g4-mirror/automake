## automake - create Makefile.in from Makefile.am
## Copyright (C) 1994-2012 Free Software Foundation, Inc.

## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2, or (at your option)
## any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

VPATH = @srcdir@

## Enhance performance by removing GNU make builtin rules that would be
## rather irrelevant (e.g., rules to automatically check out files from
## from RCS or SCCS repositories), or overridden by Automake (e.g., rules
## to compile C or C++ files).  For larger packages (like GNU coreutils),
## this can greatly speed up null or almost-null builds, up to even 50%!
MAKEFLAGS += --no-builtin-rules

# For when we need a do-nothing target.  Add an actual rule to it to avoid
# the annoying message "make[1]: Nothing to be done for .am/nil" from make.
.PHONY: .am/nil
.am/nil:
	@:

## Declare an error, without immediately terminating the execution (proper
## code will take care later of that).  This will allow us to diagnose more
## issues at once, rather than stopping at the first one.
am.error.seen :=
define am.error
$(warning $1)$(eval am.error.seen := yes)
endef

# Some problematic characters (especially when used in arguments
# to make functions, or for syntax highlighting).
am.chars.bslash := \\
am.chars.comma := ,
am.chars.dollar := $$
am.chars.hash := \#
am.chars.lparen := (
am.chars.rparen := )
am.chars.bquote := `
am.chars.dquote := "
am.chars.squote := '
# "` # Fix font-lock.

# A literal newline character, that does not get stripped if used
# at the end of the expansion of another macro.
define am__newline

$(am.chars.empty)
endef

## Makefiles generated by Automake-NG require GNU make >= 3.81.
## The .FEATURES special variable has been introduced in that make
## version, so use it as a witness to determine whether the current
## make is good enough.
ifndef .FEATURES
  $(error Automake-NG based builds require GNU make 3.81 or later)
endif

## Neutralize unwarranted environment settings that might interfere with
## our Makefiles.
ifdef SUBDIRS
  ifneq "$(origin SUBDIRS)" "file"
    ifneq "$(origin SUBDIRS)" "command line"
      SUBDIRS :=
    endif
  endif
endif

# CDPATH is only useful in interactive usage, and should never be exported
# in the environment; doing so could cause our recipes and scripts to chdir
# to unexpected places, causing all sort of hard to reproduce mayhem.
# Still, but some people nonetheless export CDPATH (or did so in the past),
# so to be extra safe we have to neutralize it.
unexport CDPATH

# Be verbose by deafault.  Yes, we really want $(V) to be overridable
# from the environment, both for simplicity and for consistency with
# mainline Automake.
# FIXME: maybe normalize/sanitize $(V)?
V ?= 0

am__mkdir = test -d $1 || $(MKDIR_P) $1

# In a recipe, ensure the given directory exists, creating it if
# necessary; but tries to do so avoiding useless forks, stats, and
# extra recipe text (the latter is useful when doing "make V=1").
# If the target has no directory component, or if the parent
# directory of the target already exists, we have nothing to do, so
# try to optimize for those cases -- especially because, for our
# usage patterns, one of them should always be true in non-VPATH
# builds.
am__ensure_dir_exists = \
  $(if $(filter .,$1),:,$(if $(wildcard $1/),:,$(call am__mkdir,$1)))

# Ensure the directory containing the target of the current recipe
# exists, by creating it if necessary.
am__ensure_target_dir_exists = $(call am__ensure_dir_exists,$(@D))

## The 'all' target must be the default one, independently from the
## position it is declared in the output Makefile.
.DEFAULT_GOAL := all

# Solaris 10 'make', and several other traditional 'make' implementations,
# pass "-e" to $(SHELL), and POSIX 2008 even requires this.  Work around it
# by disabling -e (using the XSI extension "set +e") if it's set.
am__sh_e_setup = case $$- in *e*) set +e;; esac

## Emulate VPATH rewrites.  This uses only GNU make primitives, which
## allows us to avoid extra forks.
am__vpath_rewrite = \
  $(firstword $(wildcard $(strip $(1))) $(srcdir)/$(strip $(1)))

## We used to define this.  However, we don't because vendor makes
## (e.g., Solaris, Irix) won't correctly propagate variables that are
## defined in Makefile.  This particular variable can't be correctly
## defined by configure (at least, not the current configure), so we
## simply avoid defining it to allow the user to use this feature with
## a vendor make.
## DESTDIR =

## Tell whether make is running in "dry mode".  It is either 'true' or
## 'false', so that it can be easily used in shell code as well as in
## GNU make conditionals.
## If we run "make TESTS='snooze nap'", GNU make will export MAKEFLAGS to
## "TESTS=foo\ nap", so that the builtins operating on word-split lists
## would see a "make flag" equal to "nap" when analyzing $(MAKEFLAGS), and
## would wrongly misinterpret that as and indication that make is running
## in dry mode.  This has already happened in practice.  So we need the
## hack with $(subst \ , ...).
am__make_dryrun := \
  $(strip $(if $(strip \
    $(foreach am__v, $(subst \ ,,$(strip $(MAKEFLAGS))), \
      $(if $(or $(findstring =,$(am__v)),$(filter --%,$(am__v))),, \
        $(findstring n,$(am__v))))), \
    true, false))

# An empty string.  It can be very useful to "fool" the make parser w.r.t.
# whitespace handling, and allow us to obtain tricky semantics.  See the
# definition of $(am__newline) below for a significant example.
am.chars.empty :=

am__strip_firstword = $(wordlist 2,$(words $(1)),$(1))
am__strip_lastword  = $(wordlist 2,$(words $(1)),dummy $(1))

## Remove repeated elements from the given list (without reordering),
## and return the reduced list.
am__uniq = $(strip \
## If the list is empty, we have nothing to do.  Otherwise, go on.
  $(if $(strip $(1)), \
## Call the function recursively on the list of all the elements
## but the last one.
    $(call am__uniq, \
      $(call am__strip_lastword, $(1))) \
## And append the last element, unless it was already present.
      $(if $(filter $(lastword $(1)), \
                    $(call am__strip_lastword, $(1))), \
           $(am.chars.empty), \
           $(lastword $(1)))))

?HANDLE-EXEEXT?am__handle_exeext := yes
?!HANDLE-EXEEXT?am__handle_exeext := no

## These definitions have been generated by the following Bash 4 script:
##
##    #!/bin/bash
##    toupper='$1' tolower='$1'
##    for c in {a..z}; do
##        C=${c^^}
##        toupper="\$(subst $c,$C,$toupper)"
##        tolower="\$(subst $C,$c,$tolower)"
##    done
##    echo "am__tolower = $tolower"
##    echo "am__toupper = $toupper"

am__tolower = $(subst Z,z,$(subst Y,y,$(subst X,x,$(subst W,w,$(subst V,v,$(subst U,u,$(subst T,t,$(subst S,s,$(subst R,r,$(subst Q,q,$(subst P,p,$(subst O,o,$(subst N,n,$(subst M,m,$(subst L,l,$(subst K,k,$(subst J,j,$(subst I,i,$(subst H,h,$(subst G,g,$(subst F,f,$(subst E,e,$(subst D,d,$(subst C,c,$(subst B,b,$(subst A,a,$1))))))))))))))))))))))))))

am__toupper = $(subst z,Z,$(subst y,Y,$(subst x,X,$(subst w,W,$(subst v,V,$(subst u,U,$(subst t,T,$(subst s,S,$(subst r,R,$(subst q,Q,$(subst p,P,$(subst o,O,$(subst n,N,$(subst m,M,$(subst l,L,$(subst k,K,$(subst j,J,$(subst i,I,$(subst h,H,$(subst g,G,$(subst f,F,$(subst e,E,$(subst d,D,$(subst c,C,$(subst b,B,$(subst a,A,$1))))))))))))))))))))))))))

# Canonicalize the given filename.  See also the &canonicalize function
# in the automake script.

am__canon = $(strip \
  $(subst ~,_,\
  $(subst },_,\
  $(subst |,_,\
  $(subst {,_,\
  $(subst $(am.chars.bquote),_,\
  $(subst ^,_,\
  $(subst $(am.chars.bslash),_,\
  $(subst [,_,\
  $(subst ],_,\
  $(subst ?,_,\
  $(subst >,_,\
  $(subst =,_,\
  $(subst <,_,\
  $(subst ;,_,\
  $(subst :,_,\
  $(subst /,_,\
  $(subst .,_,\
  $(subst -,_,\
  $(subst $(am.chars.comma),_,\
  $(subst +,_,\
  $(subst *,_,\
  $(subst $(am.chars.lparen),_,\
  $(subst $(am.chars.rparen),_,\
  $(subst $(am.chars.squote),_,\
  $(subst &,_,\
  $(subst %,_,\
  $(subst $(am.chars.dollar),_,\
  $(subst $(am.chars.hash),_,\
  $(subst $(am.chars.dquote),_,\
  $(subst !,_,$1)))))))))))))))))))))))))))))))


## Simple memoization for recursive make variables.  It is useful for
## situations where immediate variables can't be used (due, say, to
## ordering issues with the assignments of the referenced variables),
## but where the value of the lazy variable is costly to calculate
## (e.g., a $(shell ...) call with a non-trivial command line), so that
## we can't afford to re-calculate it over and over every time the
## variable gets expanded.  Example of usage:
##
##   var1 = $(am__memoize,var1,$(shell EXPENSIVE-COMMAND-LINE))
##   var2 = $(am__memoize,var2,$(sort VERY-LONG-LIST))
##
## This API and implementation seems to work around a bug in GNU make
## (present up to and including version 3.82) which caused our first
## implementation attempts to fail:
##
##   <http://lists.gnu.org/archive/html/bug-make/2012-05/msg00013.html>
##   <https://savannah.gnu.org/patch/?7534>
##
## So please don't change this without a very good reason.
##
am__memoize = $(or $(am__memoized_value/$1),$(strip \
  $(eval am__memoized_value/$1 := $$2))$(am__memoized_value/$1))

## $(call am__strip_suffixes, SUFFIXES, LIST)
## ------------------------------------------
## Strip any of the SUFFIXES from each of the entries of LIST.  Even if an
## entry of LIST terminates with several suffixes, only one is stripped:
## the first one that matches.
am__private_suffix = .,;&!@
am__strip_suffixes = $(strip \
  $(if \
    $(strip $1), \
      $(patsubst %$(am__private_suffix),%, \
        $(call am__strip_suffixes, \
          $(call am__strip_firstword,$1), \
          $(patsubst %$(firstword $1),%$(am__private_suffix),$2))), \
    $2))

# Helper variables and function to help in recipes that could exceed
# the command line length limit.

## FIXME: Forty aguments; this is basically arbitrary.  In the long term,
## FIXME: defining this after a configure-time test on the command-line
## FIXME: length limits, or at least on a system-by-system basis, might
## FIXME: be better.  But don't make it too big, or our implementation
## FIXME: will likely suffer in performance and memory consumption.
# And in the Information Age, we somehow managed to revert to abacus-like
# counting.  Yay for us :-)
am.max-cmdline-args := xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# $(call am.xargs-map,FUNCTION,LIST)
# ----------------------------------
# Map the function $1 on the arguments $2, ensuring that each
# call of $1 has at most 40 arguments.
# This implementation is hacky, but the more elegant or "naive" ones
# (based on recursion) proved to be ludicrously memory-hungry with
# huge lists.
# A drawback of this implementation is that am.xargs-map cannot be
# recursively invoked, but that shouldn't matter for our use cases.
# The extra $(strip) calls are only to allow clearer formatting.
define am.xargs-map
$(if $2,$(strip \
  )$(eval $0.partial-args :=)$(strip \
  )$(eval $0.counter :=)$(strip \
  )$(foreach i,$2,$(strip \
    )$(eval $0.counter := $$($0.counter)x)$(strip \
    )$(eval $0.partial-args += $$i)$(strip \
    )$(if $(filter $(am.max-cmdline-args),$($0.counter)),$(strip \
      )$(call $1,$(strip $($0.partial-args)))$(strip \
      )$(eval $0.partial-args :=)$(strip \
      )$(eval $0.counter :=)))$(strip \
  )$(if $($0.counter),$(call $1,$(strip $($0.partial-args)))))
endef

## Some derived variables that have been found to be useful.
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@

install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)

## These are defined because otherwise make on NetBSD V1.1 will print
## (eg): $(NORMAL_INSTALL) expands to empty string.
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :

## dejagnu.am uses these variables.  Some users might rely on them too.
?BUILD?build_triplet = @build@
?HOST?host_triplet = @host@
?TARGET?target_triplet = @target@

## automake - create Makefile.in from Makefile.am
## Copyright (C) 2001-2012 Free Software Foundation, Inc.

## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2, or (at your option)
## any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

am__tty_colors_dummy = \
  mgn= red= grn= lgn= blu= brg= std=; \
  am__color_tests=no
if %?COLOR%
# If stdout is a non-dumb tty, use colors.  If test -t is not supported,
# then this fails; a conservative approach.  Of course do not redirect
# stdout here, just stderr.
am__tty_colors = \
$(am__tty_colors_dummy); \
test "X$(AM_COLOR_TESTS)" != Xno \
&& test "X$$TERM" != Xdumb \
&& { test "X$(AM_COLOR_TESTS)" = Xalways || test -t 1 2>/dev/null; } \
&& { \
  am__color_tests=yes; \
  red='[0;31m'; \
  grn='[0;32m'; \
  lgn='[1;32m'; \
  blu='[1;34m'; \
  mgn='[0;35m'; \
  brg='[1m'; \
  std='[m'; \
}
else !%?COLOR%
am__tty_colors = $(am__tty_colors_dummy)
endif !%?COLOR%

.PHONY: check-TESTS

if %?PARALLEL_TESTS%

## New parallel test driver.
##
## The first version of the code here was adapted from check.mk, which was
## originally written at EPITA/LRDE, further developed at Gostai, then made
## its way from GNU coreutils to end up, largely rewritten, in Automake.
## The current version is an heavy rewrite of that, to allow for support
## of more test metadata, and the use of custom test derivers and protocols
## (among them, TAP).

# Required to support explicit use of $(srcdir) in TESTS entries.
# That might actually be very useful in practice, for example in usages
# like this:
#   TESTS = $(wildcard $(srcdir)/t[0-9][0-9]*.sh)
# Removing the '$(srcdir)' in there would cause the idiom to break in
# VPATH builds.
am__cooked_tests = $(patsubst $(srcdir)/%,%,$(strip $(TESTS)))
am__cooked_xfail_tests = $(patsubst $(srcdir)/%,%,$(strip $(XFAIL_TESTS)))

# Restructured Text title and section.
am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
am__rst_section = { sed 'p;s/./=/g;' && echo; }

# Solaris 10 'make', and several other traditional 'make' implementations,
# pass "-e" to $(SHELL), and POSIX 2008 even requires this.  Work around it
# by disabling -e (using the XSI extension "set +e") if it's set.
am__sh_e_setup = case $$- in *e*) set +e;; esac

# Default flags passed to test drivers.
am__common_driver_flags = \
  --color-tests "$$am__color_tests" \
  --enable-hard-errors "$$am__enable_hard_errors" \
  --expect-failure "$$am__expect_failure"

# To be inserted before the command running the test.  Creates the
# directory for the log if needed.  Stores in $dir the directory
# containing $f, in $tst the test, in $log the log.  Executes the
# developer- defined test setup AM_TESTS_ENVIRONMENT (if any), and
# passes TESTS_ENVIRONMENT.  Set up options for the wrapper that
# will run the test scripts (or their associated LOG_COMPILER, if
# thy have one).
am__check_pre =						\
$(am__sh_e_setup);					\
$(am__tty_colors);					\
srcdir=$(srcdir); export srcdir;			\
test x$(@D) = x. || test -d $(@D) || $(MKDIR_P) $(@D) || exit $$?; \
f='$(patsubst $(srcdir)/%,%,$<)';			\
## We need to invoke the test in way that won't cause a PATH search.
## Quotes around '$<' are required to avoid extra errors when a circular
## dependency is detected (e.g., because $(TEST_SUITE_LOG) is in
## $(TEST_LOGS)), because in that case '$<' expands to empty and an
## unquote usage of it could cause syntax errors in the shell.
case '$<' in */*) tst='$<';; *) tst=./'$<';; esac;	\
if test -n '$(DISABLE_HARD_ERRORS)'; then		\
  am__enable_hard_errors=no; 				\
else							\
  am__enable_hard_errors=yes; 				\
fi; 							\
case " $(am__cooked_xfail_tests) " in			\
  *" $$f "*) am__expect_failure=yes;;			\
          *) am__expect_failure=no;;			\
esac; 							\
$(AM_TESTS_ENVIRONMENT) $(TESTS_ENVIRONMENT)

# The names of the tests scripts with any registered extension removed
# (i.e., equivalently, the names of the test logs, with the '.log' suffix
# stripped), and the name of the test result files (i.e., equivalently, the
# names of the test logs, with the '.log' suffix substituted by the '.trs'
# suffix).  This honors runtime overriding of TESTS and TEST_LOGS.  It
# also works around the GNU make 3.80 bug where trailing whitespace in
# "TESTS = foo.test $(empty)" causes $(TESTS_LOGS) to erroneously expand
# to "foo.log .log".
am__TEST_BASES   = $(patsubst %.log,%,$(strip $(TEST_LOGS)))
am__TEST_RESULTS = $(patsubst %.log,%.trs,$(strip $(TEST_LOGS)))

$(TEST_SUITE_LOG): $(TEST_LOGS) $(am__TEST_RESULTS)
	@$(am__sh_e_setup); $(am__tty_colors); \
	fatal () { echo "fatal: making $@: $$*" >&2; exit 1; }; \
## Detect a possible circular dependency, and error out.
	case ' $(strip $(TEST_LOGS)) ' in *' $(TEST_SUITE_LOG) '*) \
	  fatal "depends on itself (check TESTS content)";; \
	esac; \
	ws='[ 	]'; \
	count_result () \
	{ \
	  r='$(strip $(am__TEST_RESULTS))'; \
	  r=`grep "^$$ws*:test-result:$$ws*$${1-}" $$r </dev/null`; \
## Catch I/O errors, and complain accordingly.
	  test $$? -le 1 || fatal "I/O error reading test results"; \
	  case $$r in \
	    "") echo 0;; \
	    * ) printf '%s\n' "$$r" | wc -l;; \
	  esac; \
	}; \
## Prepare data for the test suite summary.  These do not take into account
## unreadable test results, but they'll be appropriately updated later if
## needed.
	all=`count_result` \
	  && pass=` count_result PASS` \
	  && fail=` count_result FAIL` \
	  && skip=` count_result SKIP` \
	  && xfail=`count_result XFAIL` \
	  && xpass=`count_result XPASS` \
	  && error=`count_result ERROR` \
	  || exit 1; \
## Whether the testsuite was successful or not.
	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
	  success=true; \
	else \
	  success=false; \
	fi; \
## Make $br a line of exactly 76 '=' characters, that will be used to
## enclose the testsuite summary report when displayed on the console.
	br='==================='; br=$$br$$br$$br$$br; \
## When writing the test summary to the console, we want to color a line
## reporting the count of some result *only* if at least one test
## experienced such a result.  This function is handy in this regard.
	result_count () \
	{ \
	    if test x"$$1" = x"--maybe-color"; then \
	      maybe_colorize=yes; \
	    elif test x"$$1" = x"--no-color"; then \
	      maybe_colorize=no; \
	    else \
	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
	    fi; \
	    shift; \
	    desc=$$1 count=$$2; \
	    if test $$maybe_colorize = yes && test $$count -gt 0; then \
	      color_start=$$3 color_end=$$std; \
	    else \
	      color_start= color_end=; \
	    fi; \
	    echo "$${color_start}# $$desc $$count$${color_end}"; \
	}; \
## A shell function that creates the testsuite summary.  We need it
## because we have to create *two* summaries, one for test-suite.log,
## and a possibly-colorized one for console output.
	create_testsuite_report () \
	{ \
	  result_count $$1 "TOTAL:" $$all   "$$brg"; \
	  result_count $$1 "PASS: " $$pass  "$$grn"; \
	  result_count $$1 "SKIP: " $$skip  "$$blu"; \
	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
	  result_count $$1 "FAIL: " $$fail  "$$red"; \
	  result_count $$1 "XPASS:" $$xpass "$$red"; \
	  result_count $$1 "ERROR:" $$error "$$mgn"; \
	}; \
## Write "global" testsuite log.
	if {								\
	  st=0; 							\
	  echo "$(PACKAGE_STRING): $(subdir)/$(TEST_SUITE_LOG)" |	\
	    $(am__rst_title);						\
	  create_testsuite_report --no-color;				\
	  echo;								\
	  echo ".. contents:: :depth: 2";				\
	  echo;								\
	  bases='$(am__TEST_BASES)'; for i in $$bases; do		\
## FIXME: one fork per test -- this is horrendously inefficient!
	    if grep "^$$ws*:copy-in-global-log:$$ws*no$$ws*$$" $$i.trs \
	         >/dev/null; then continue; \
	    fi; \
## Get the declared "global result" of the test.
## FIXME: yet another one fork per test here!
	    glob_res=`sed -n -e "s/$$ws*$$//" \
	                     -e "s/^$$ws*:global-test-result:$$ws*//p" \
		        $$i.trs`; \
## If no global result is explicitly declared, we'll merely mark the
## test as "RUN" in the global test log.
	    test -n "$$glob_res" || glob_res=RUN; \
## Write the name and result of the test as an RST section title.
	    echo "$$glob_res: $$i" | $(am__rst_section); \
## Register any failure in reading test logs, to report an error later.
	    cat $$i.log || st=1; \
	    echo; \
	  done;	\
	  test $$st -eq 0; \
	} >$(TEST_SUITE_LOG).tmp; then \
	  mv -f $(TEST_SUITE_LOG).tmp $(TEST_SUITE_LOG); \
	else \
	  rm -f $(TEST_SUITE_LOG).tmp; \
	  fatal "I/O error reading test logs"; \
	fi; \
## Emit the test summary on the console.
	if $$success; then						\
	  col="$$grn";							\
	 else								\
	  col="$$red";							\
	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
	fi;								\
## Multi line coloring is problematic with "less -R", so we really need
## to color each line individually.
	echo "$${col}$$br$${std}"; 					\
	echo "$${col}Testsuite summary for $(PACKAGE_STRING)$${std}";	\
	echo "$${col}$$br$${std}"; 					\
## This is expected to go to the console, so it might have to be colorized.
	create_testsuite_report --maybe-color;				\
	echo "$$col$$br$$std";						\
	if $$success; then :; else					\
	  echo "$${col}See $(subdir)/$(TEST_SUITE_LOG)$${std}";		\
	  if test -n "$(PACKAGE_BUGREPORT)"; then			\
	    echo "$${col}Please report to $(PACKAGE_BUGREPORT)$${std}";	\
	  fi;								\
	  echo "$$col$$br$$std";					\
	fi;								\
	$$success || exit 1

RECHECK_LOGS = $(TEST_LOGS)

## ------------------------------------------ ##
## Running all tests, or rechecking failures. ##
## ------------------------------------------ ##

check-TESTS recheck:
## If we are running "make recheck", it's not the user which can decide
## which tests to consider for re-execution, so we must ignore the value
## of $(RECHECK_LOGS).
## Here and below, we expand $(RECHECK_LOGS) only once, to avoid exceeding
## line length limits.
	@if test $@ != recheck; then \
	   list='$(RECHECK_LOGS)'; \
	   test -z "$$list" || rm -f $$list; \
	 fi
	@if test $@ != recheck; then \
	   list='$(RECHECK_LOGS:.log=.trs)'; \
	   test -z "$$list" || rm -f $$list; \
	 fi
## We always have to remove TEST_SUITE_LOG, to ensure its rule is run
## in any case even in lazy mode: otherwise, if no test needs rerunning,
## or a prior run plus reruns all happen within the same timestamp (can
## happen with a prior "make TESTS=<subset>"), then we get no log output.
## OTOH, this means that, in the rule for '$(TEST_SUITE_LOG)', we
## cannot use '$?' to compute the set of lazily rerun tests, lest
## we rely on .PHONY to work portably.
	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
	@ws='[ 	]'; \
	log_list='' trs_list=''; bases='$(am__TEST_BASES)'; \
	for i in $$bases; do \
## If running a "make recheck", we must only consider tests that had an
## unexpected outcome (FAIL or XPASS) in the earlier run.  In particular,
## skip tests that haven't been run.  But recover gracefully from deleted
## '.trs' files.
	  if test $@ = recheck; then \
	    test -f $$i.trs || test -f $$i.log || continue; \
## FIXME: one fork per test -- this is horrendously inefficient!
	    grep "^$$ws*:recheck:$$ws*no$$ws*$$" $$i.trs \
	      >/dev/null 2>&1 && continue; \
	  else :; fi; \
	  log_list="$$log_list $$i.log"; \
	  trs_list="$$trs_list $$i.trs"; \
	done; \
## Under "make recheck", remove the .log and .trs files associated
## with the files to recheck, so that those will be rerun by the
## "make test-suite.log" recursive invocation below.  But use a proper
## hack to avoid extra files removal when running under "make -n".
	if test $@ != recheck || $(am__make_dryrun); then :; else \
	  test -z "$$log_list" || rm -f $$log_list; \
	  test -z "$$trs_list" || rm -f $$trs_list; \
	fi; \
	$(MAKE) $(TEST_SUITE_LOG) TEST_LOGS="$$log_list"

## Recheck must depend on $(check_SCRIPTS), $(check_PROGRAMS), etc.
## It must also depend on the 'all' target.  See automake bug#11252.
recheck: all %CHECK_DEPS%

AM_RECURSIVE_TARGETS += check recheck

.PHONY: recheck

else !%?PARALLEL_TESTS%

check-TESTS: $(TESTS)
	@failed=0; all=0; xfail=0; xpass=0; skip=0; \
	srcdir=$(srcdir); export srcdir; \
	list='$(TESTS)'; \
	$(am__tty_colors); \
	if test -n "$$list"; then \
	  for tst in $$list; do \
	    if test -f ./$$tst; then dir=./; \
	    else dir="$(srcdir)/"; fi; \
	    if $(TESTS_ENVIRONMENT) $${dir}$$tst $(AM_TESTS_FD_REDIRECT); then \
## Success
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xpass=`expr $$xpass + 1`; \
		failed=`expr $$failed + 1`; \
		col=$$red; res=XPASS; \
	      ;; \
	      *) \
		col=$$grn; res=PASS; \
	      ;; \
	      esac; \
	    elif test $$? -ne 77; then \
## Failure
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xfail=`expr $$xfail + 1`; \
		col=$$lgn; res=XFAIL; \
	      ;; \
	      *) \
		failed=`expr $$failed + 1`; \
		col=$$red; res=FAIL; \
	      ;; \
	      esac; \
	    else \
## Skipped
	      skip=`expr $$skip + 1`; \
	      col=$$blu; res=SKIP; \
	    fi; \
	    echo "$${col}$$res$${std}: $$tst"; \
	  done; \
## Prepare the banner
	  if test "$$all" -eq 1; then \
	    tests="test"; \
	    All=""; \
	  else \
	    tests="tests"; \
	    All="All "; \
	  fi; \
	  if test "$$failed" -eq 0; then \
	    if test "$$xfail" -eq 0; then \
	      banner="$$All$$all $$tests passed"; \
	    else \
	      if test "$$xfail" -eq 1; then failures=failure; else failures=failures; fi; \
	      banner="$$All$$all $$tests behaved as expected ($$xfail expected $$failures)"; \
	    fi; \
	  else \
	    if test "$$xpass" -eq 0; then \
	      banner="$$failed of $$all $$tests failed"; \
	    else \
	      if test "$$xpass" -eq 1; then passes=pass; else passes=passes; fi; \
	      banner="$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)"; \
	    fi; \
	  fi; \
## DASHES should contain the largest line of the banner.
	  dashes="$$banner"; \
	  skipped=""; \
	  if test "$$skip" -ne 0; then \
	    if test "$$skip" -eq 1; then \
	      skipped="($$skip test was not run)"; \
	    else \
	      skipped="($$skip tests were not run)"; \
	    fi; \
	    test `echo "$$skipped" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$skipped"; \
	  fi; \
	  report=""; \
	  if test "$$failed" -ne 0 && test -n "$(PACKAGE_BUGREPORT)"; then \
	    report="Please report to $(PACKAGE_BUGREPORT)"; \
	    test `echo "$$report" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$report"; \
	  fi; \
	  dashes=`echo "$$dashes" | sed s/./=/g`; \
	  if test "$$failed" -eq 0; then \
	    col="$$grn"; \
	  else \
	    col="$$red"; \
	  fi; \
## Multi line coloring is problematic with "less -R", so we really need
## to color each line individually.
	  echo "$${col}$$dashes$${std}"; \
	  echo "$${col}$$banner$${std}"; \
	  test -z "$$skipped" || echo "$${col}$$skipped$${std}"; \
	  test -z "$$report" || echo "$${col}$$report$${std}"; \
	  echo "$${col}$$dashes$${std}"; \
	  test "$$failed" -eq 0; \
	else :; fi

endif !%?PARALLEL_TESTS%

## automake - create Makefile.in from Makefile.am
## Copyright (C) 2001-2012 Free Software Foundation, Inc.

## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2, or (at your option)
## any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

am__tty_colors_dummy = \
  mgn= red= grn= lgn= blu= brg= std=; \
  am__color_tests=no
if %?COLOR%
am__tty_colors = { \
  $(am__tty_colors_dummy); \
  if test "X$(AM_COLOR_TESTS)" = Xno; then \
    am__color_tests=no; \
  elif test "X$(AM_COLOR_TESTS)" = Xalways; then \
    am__color_tests=yes; \
## If stdout is a non-dumb tty, use colors.  If test -t is not supported,
## then this check fails; a conservative approach.  Of course do not
## redirect stdout here, just stderr.
  elif test "X$$TERM" != Xdumb && { test -t 1; } 2>/dev/null; then \
    am__color_tests=yes; \
  fi; \
  if test $$am__color_tests = yes; then \
    red='[0;31m'; \
    grn='[0;32m'; \
    lgn='[1;32m'; \
    blu='[1;34m'; \
    mgn='[0;35m'; \
    brg='[1m'; \
    std='[m'; \
  fi; \
}
else !%?COLOR%
am__tty_colors = $(am__tty_colors_dummy)
endif !%?COLOR%

.PHONY: check-TESTS

if %?PARALLEL_TESTS%

## New parallel test driver.
##
## The first version of the code here was adapted from check.mk, which was
## originally written at EPITA/LRDE, further developed at Gostai, then made
## its way from GNU coreutils to end up, largely rewritten, in Automake.
## The current version is an heavy rewrite of that, to allow for support
## of more test metadata, and the use of custom test derivers and protocols
## (among them, TAP).

# The names of the given tests scripts with any possible registered
# test extension removed, as well as any leading '$(srcdir)' component
# (if any) stripped.
# The stripping of $(srcdir) is required to support explicit use of
# $(srcdir) in TESTS entries.  That might actually be very useful in
# practice, for example in usages like this:
#   TESTS = $(wildcard $(srcdir)/t[0-9][0-9]*.sh)
# where removing the $(srcdir) from the $(wildcard) invocation would
# cause the idiom to break in VPATH builds.
am__get_test_bases = $(patsubst $(srcdir)/%,%,$(strip \
$(call am__strip_suffixes, $(TEST_EXTENSIONS), \
?!HANDLE-EXEEXT?             $(1))))
?HANDLE-EXEEXT?              $(patsubst %$(EXEEXT),%,$(1)))))

am__recheck_rx = ^[ 	]*:recheck:[ 	]*
am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*

# A command that, given a newline-separated list of test names on the
# standard input, print the name of the tests that are to be re-run
# upon "make recheck".
am__list_recheck_tests = $(AWK) '{ \
## By default, we assume the test is to be re-run.
  recheck = 1; \
  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
    { \
      if (rc < 0) \
        { \
## If we've encountered an I/O error here, there are three possibilities:
##
##  [1] The '.log' file exists, but the '.trs' does not; in this case,
##      we "gracefully" recover by assuming the corresponding test is
##      to be re-run (which will re-create the missing '.trs' file).
##
##  [2] Both the '.log' and '.trs' files are missing; this means that
##      the corresponding test has not been run, and is thus *not* to
##      be re-run.
##
##  [3] We have encountered some corner-case problem (e.g., a '.log' or
##      '.trs' files somehow made unreadable, or issues with a bad NFS
##      connection, or whatever); we don't handle such corner cases.
##
          if ((getline line2 < ($$0 ".log")) < 0) \
	    recheck = 0; \
          break; \
        } \
      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
## A directive explicitly specifying the test is *not* to be re-run.
        { \
          recheck = 0; \
          break; \
        } \
      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
        { \
## A directive explicitly specifying the test *is* to be re-run.
          break; \
        } \
## else continue with the next iteration.
    }; \
  if (recheck) \
    print $$0; \
## Don't leak open file descriptors, as this could cause serious
## problems when there are many tests (yes, even on Linux).
  close ($$0 ".trs"); \
  close ($$0 ".log"); \
}'

# A command that, given a newline-separated list of test names on the
# standard input, create the global log from their .trs and .log files.
am__create_global_log = $(AWK) ' \
## Don't leak open file descriptors, as this could cause serious
## problems when there are many tests (yes, even on Linux).
function close_current() \
{ \
  close ($$0 ".trs"); \
  close ($$0 ".log"); \
} \
function error(msg) \
{ \
  print msg | "cat >&2"; \
  exit_status = 1; \
} \
function input_error(file) \
{ \
  error("awk" ": cannot read \"" file "\""); \
  close_current(); \
  next; \
} \
function rst_section(header) \
{ \
  print header; \
  len = length(header); \
  for (i = 1; i <= len; i = i + 1) \
    printf "="; \
  printf "\n\n"; \
} \
BEGIN { exit_status = 0; } \
{ \
## By default, we assume the test log is to be copied in the global log,
## and that its result is simply "RUN" (i.e., we still don't know what
## it outcome was, but we know that at least it has run).
  copy_in_global_log = 1; \
  global_test_result = "RUN"; \
  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
    { \
      if (rc < 0) \
        input_error($$0 ".trs"); \
      if (line ~ /$(am__global_test_result_rx)/) \
        { \
          sub("$(am__global_test_result_rx)", "", line); \
          sub("[ 	]*$$", "", line); \
          global_test_result = line; \
        } \
      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
        copy_in_global_log = 0; \
    }; \
  if (copy_in_global_log) \
    { \
      rst_section(global_test_result ": " $$0); \
      while ((rc = (getline line < ($$0 ".log"))) != 0) \
      { \
        if (rc < 0) \
          input_error($$0 ".log"); \
        print line; \
      }; \
      printf "\n"; \
    }; \
  close_current(); \
} \
END { \
  if (exit_status != 0) \
    error("fatal: making $@: I/O error reading test results"); \
  exit(exit_status); \
}'

# Restructured Text title.
am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }

# This supports runtime overriding of $(TESTS) and $(XFAIL_TESTS).
am__test_bases       = $(call am__get_test_bases, $(TESTS))
am__xfail_test_bases = $(call am__get_test_bases, $(XFAIL_TESTS))

# The $(strip) is to work around the GNU make 3.80 bug where trailing
# whitespace in "TESTS = foo.test $(empty)" causes $(TESTS_LOGS) to
# erroneously expand to "foo.log .log".
am__test_results = $(addsuffix .trs,$(strip $(am__test_bases)))
am__test_logs    = $(addsuffix .log,$(strip $(am__test_bases)))

# $(TEST_LOGS) is a published interface.
TEST_LOGS = $(am__test_logs)

$(TEST_SUITE_LOG): $(am__test_logs) $(am__test_results)
	@$(am__sh_e_setup); $(am__tty_colors); \
	fatal () { echo "fatal: making $@: $$*" >&2; exit 1; }; \
## Detect a possible circular dependency, and error out.
	case ' $(strip $(am__test_logs)) ' in *' $(TEST_SUITE_LOG) '*) \
	  fatal "depends on itself (check TESTS content)";; \
	esac; \
	ws='[ 	]'; \
	count_result () \
	{ \
	  r='$(strip $(am__test_results))'; \
	  r=`grep "^$$ws*:test-result:$$ws*$${1-}" $$r </dev/null`; \
## Catch I/O errors, and complain accordingly.
	  test $$? -le 1 || fatal "I/O error reading test results"; \
	  case $$r in \
	    "") echo 0;; \
	    * ) printf '%s\n' "$$r" | wc -l;; \
	  esac; \
	}; \
## Prepare data for the test suite summary.  These do not take into account
## unreadable test results, but they'll be appropriately updated later if
## needed.
	all=`count_result` \
	  && pass=` count_result PASS` \
	  && fail=` count_result FAIL` \
	  && skip=` count_result SKIP` \
	  && xfail=`count_result XFAIL` \
	  && xpass=`count_result XPASS` \
	  && error=`count_result ERROR` \
	  || exit 1; \
## Whether the testsuite was successful or not.
	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
	  success=true; \
	else \
	  success=false; \
	fi; \
## Make $br a line of exactly 76 '=' characters, that will be used to
## enclose the testsuite summary report when displayed on the console.
	br='==================='; br=$$br$$br$$br$$br; \
## When writing the test summary to the console, we want to color a line
## reporting the count of some result *only* if at least one test
## experienced such a result.  This function is handy in this regard.
	display_result_count () \
	{ \
	    if test x"$$1" = x"--maybe-color"; then \
	      maybe_colorize=yes; \
	    elif test x"$$1" = x"--no-color"; then \
	      maybe_colorize=no; \
	    else \
	      echo "$@: invalid 'display_result_count' usage" >&2; \
	      exit 4; \
	    fi; \
	    shift; \
	    desc=$$1 count=$$2; \
	    if test $$maybe_colorize = yes && test $$count -gt 0; then \
	      color_start=$$3 color_end=$$std; \
	    else \
	      color_start= color_end=; \
	    fi; \
	    echo "$${color_start}# $$desc $$count$${color_end}"; \
	}; \
## A shell function that creates the testsuite summary.  We need it
## because we have to create *two* summaries, one for test-suite.log,
## and a possibly-colorized one for console output.
	create_testsuite_report () \
	{ \
	  opts=$$*; \
	  display_result_count $$opts "TOTAL:" $$all   "$$brg"; \
	  display_result_count $$opts "PASS: " $$pass  "$$grn"; \
	  display_result_count $$opts "SKIP: " $$skip  "$$blu"; \
	  display_result_count $$opts "XFAIL:" $$xfail "$$lgn"; \
	  display_result_count $$opts "FAIL: " $$fail  "$$red"; \
	  display_result_count $$opts "XPASS:" $$xpass "$$red"; \
	  display_result_count $$opts "ERROR:" $$error "$$mgn"; \
	}; \
## Write "global" testsuite log.
	if {								\
	  st=0; 							\
	  echo "$(PACKAGE_STRING): $(subdir)/$(TEST_SUITE_LOG)" |	\
	    $(am__rst_title);						\
	  create_testsuite_report --no-color;				\
	  echo;								\
	  echo ".. contents:: :depth: 2";				\
	  echo;								\
	  bases='$(am__test_bases)';					\
	  for b in $$bases; do echo $$b; done				\
	    | $(am__create_global_log);					\
	} >$(TEST_SUITE_LOG).tmp; then					\
	  mv -f $(TEST_SUITE_LOG).tmp $(TEST_SUITE_LOG);		\
	else								\
## The awk program in $(am__create_global_log) should have already emitted
## a proper error message about I/O error, no need to repeat it.
	  rm -f $(TEST_SUITE_LOG).tmp; exit 1;				\
	fi;								\
## Emit the test summary on the console.
	if $$success; then						\
	  col="$$grn";							\
	 else								\
	  col="$$red";							\
	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
	fi;								\
## Multi line coloring is problematic with "less -R", so we really need
## to color each line individually.
	echo "$${col}$$br$${std}"; 					\
	echo "$${col}Testsuite summary for $(PACKAGE_STRING)$${std}";	\
	echo "$${col}$$br$${std}"; 					\
## This is expected to go to the console, so it might have to be colorized.
	create_testsuite_report --maybe-color;				\
	echo "$$col$$br$$std";						\
	if $$success; then :; else					\
	  echo "$${col}See $(subdir)/$(TEST_SUITE_LOG)$${std}";		\
	  if test -n "$(PACKAGE_BUGREPORT)"; then			\
	    echo "$${col}Please report to $(PACKAGE_BUGREPORT)$${std}";	\
	  fi;								\
	  echo "$$col$$br$$std";					\
	fi;								\
	$$success || exit 1

RECHECK_LOGS = $(TEST_LOGS)

## ------------------------------------------ ##
## Running all tests, or rechecking failures. ##
## ------------------------------------------ ##

check-TESTS:
## Here and below, we expand $(RECHECK_LOGS) only once, to avoid exceeding
## line length limits.
	@list='$(RECHECK_LOGS)';           test -z "$$list" || rm -f $$list
	@list='$(RECHECK_LOGS:.log=.trs)'; test -z "$$list" || rm -f $$list
## We always have to remove TEST_SUITE_LOG, to ensure its rule is run
## in any case even in lazy mode: otherwise, if no test needs rerunning,
## or a prior run plus reruns all happen within the same timestamp (can
## happen with a prior "make TESTS=<subset>"), then we get no log output.
## OTOH, this means that, in the rule for '$(TEST_SUITE_LOG)', we
## cannot use '$?' to compute the set of lazily rerun tests, lest
## we rely on .PHONY to work portably.
	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
	$(MAKE) $(TEST_SUITE_LOG)

## Recheck must depend on $(check_SCRIPTS), $(check_PROGRAMS), etc.
## It must also depend on the 'all' target.  See automake bug#11252.
recheck: all %CHECK_DEPS%
## See comments in the 'check-TESTS' recipe above for why we need
## this manual removal.
	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
	@bases='$(am__test_bases)'; \
## If running a "make recheck", we must only consider tests that had an
## unexpected outcome (FAIL or XPASS) in the earlier run.
	bases=`for i in $$bases; do echo $$i; done \
	         | $(am__list_recheck_tests)` || exit 1; \
## Remove newlines and normalize whitespace.
	bases=`echo $$bases`; \
	$(MAKE) check-TESTS am__test_bases="$$bases"
.PHONY: recheck

AM_RECURSIVE_TARGETS += check recheck

else !%?PARALLEL_TESTS%

check-TESTS: $(TESTS)
	@failed=0; all=0; xfail=0; xpass=0; skip=0; \
	srcdir=$(srcdir); export srcdir; \
	list='$(TESTS)'; \
	$(am__tty_colors); \
	if test -n "$$list"; then \
	  for tst in $$list; do \
	    if test -f ./$$tst; then dir=./; \
	    else dir="$(srcdir)/"; fi; \
	    if $(TESTS_ENVIRONMENT) $${dir}$$tst $(AM_TESTS_FD_REDIRECT); then \
## Success
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xpass=`expr $$xpass + 1`; \
		failed=`expr $$failed + 1`; \
		col=$$red; res=XPASS; \
	      ;; \
	      *) \
		col=$$grn; res=PASS; \
	      ;; \
	      esac; \
	    elif test $$? -ne 77; then \
## Failure
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xfail=`expr $$xfail + 1`; \
		col=$$lgn; res=XFAIL; \
	      ;; \
	      *) \
		failed=`expr $$failed + 1`; \
		col=$$red; res=FAIL; \
	      ;; \
	      esac; \
	    else \
## Skipped
	      skip=`expr $$skip + 1`; \
	      col=$$blu; res=SKIP; \
	    fi; \
	    echo "$${col}$$res$${std}: $$tst"; \
	  done; \
## Prepare the banner
	  if test "$$all" -eq 1; then \
	    tests="test"; \
	    All=""; \
	  else \
	    tests="tests"; \
	    All="All "; \
	  fi; \
	  if test "$$failed" -eq 0; then \
	    if test "$$xfail" -eq 0; then \
	      banner="$$All$$all $$tests passed"; \
	    else \
	      if test "$$xfail" -eq 1; then failures=failure; else failures=failures; fi; \
	      banner="$$All$$all $$tests behaved as expected ($$xfail expected $$failures)"; \
	    fi; \
	  else \
	    if test "$$xpass" -eq 0; then \
	      banner="$$failed of $$all $$tests failed"; \
	    else \
	      if test "$$xpass" -eq 1; then passes=pass; else passes=passes; fi; \
	      banner="$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)"; \
	    fi; \
	  fi; \
## DASHES should contain the largest line of the banner.
	  dashes="$$banner"; \
	  skipped=""; \
	  if test "$$skip" -ne 0; then \
	    if test "$$skip" -eq 1; then \
	      skipped="($$skip test was not run)"; \
	    else \
	      skipped="($$skip tests were not run)"; \
	    fi; \
	    test `echo "$$skipped" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$skipped"; \
	  fi; \
	  report=""; \
	  if test "$$failed" -ne 0 && test -n "$(PACKAGE_BUGREPORT)"; then \
	    report="Please report to $(PACKAGE_BUGREPORT)"; \
	    test `echo "$$report" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$report"; \
	  fi; \
	  dashes=`echo "$$dashes" | sed s/./=/g`; \
	  if test "$$failed" -eq 0; then \
	    col="$$grn"; \
	  else \
	    col="$$red"; \
	  fi; \
## Multi line coloring is problematic with "less -R", so we really need
## to color each line individually.
	  echo "$${col}$$dashes$${std}"; \
	  echo "$${col}$$banner$${std}"; \
	  test -z "$$skipped" || echo "$${col}$$skipped$${std}"; \
	  test -z "$$report" || echo "$${col}$$report$${std}"; \
	  echo "$${col}$$dashes$${std}"; \
	  test "$$failed" -eq 0; \
	else :; fi

endif !%?PARALLEL_TESTS%

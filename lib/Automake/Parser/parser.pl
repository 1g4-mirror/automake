#!/usr/bin/perl
use strict;
use Lexer;
use Tree;
use ParserTable;

#To enable debug mode, use 1
my $debug = 0;

#Stores the list of tokens generated by lexer.
my @tokens; 

my $multiline = 0;
my $curr_tokens;

#Read input from file specified in Arguements or STDIN.
while ( <> )
{
	( $curr_tokens, $multiline ) = lex( $_ , $multiline );
	push @tokens, @$curr_tokens;
}

#Prints to STDERR if Debug mode is on.
if( $debug )
{
	print STDERR "Lexer Output\n";
	foreach my $token ( @tokens )
	{
		print STDERR join(" ", @{$token}), "\n";
	}
}
#Push a newline token if last token is not newline
if( $tokens[-1][0] ne "newline" )
{
	push @tokens,["newline"];
}

push @tokens, [ "end" ];
my @stack = (0);
print STDERR "Parser Output\n" if $debug;

while ( @stack )
{
	if($stack[-1] == $ParserTable::accept)
	{
		print STDERR "Complete\n";
		printgraph( $stack[-4] );
		last;
	}
	my @curr_token = @{ $tokens[0] };	
	if(my $val = $ParserTable::table[ $stack[-1] ]{ $curr_token[0] })
	{
		push @stack, \@curr_token, $val;
		shift @tokens;
	}
	elsif(my $val = $ParserTable::table[ $stack[-1] ]{ reduce })
	{
		my @val1 = @$val;
		my @param;
		for(my $i = 1; $i <= 2 * $val1[0]; $i++)
		{
			if($i%2 == 0)
			{
				$val = pop @stack;
				push @param,$val;
			}
			else
			{
				pop @stack;
			}
		}
		@param = reverse @param;
		push @stack, $val1[1]->( @param );
		push @stack, $ParserTable::table[ $stack[-2] ]{ $stack[-1]->{ name }};
	}
	else
	{
		die "Unexpected Token ". $curr_token[1]."\n";
	}
	print STDERR @stack, "\n" if $debug;
}
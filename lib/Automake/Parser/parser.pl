#!/usr/bin/perl

BEGIN
{
	# Adds the directory containing modules which are copied during
	# make install
	unshift (@INC, '/tmp/parser');
}

use strict;
use Lexer;
use Tree;
use ParserTable;
use File::Basename;
use Data::Dumper;

# Checks if the parser is called on a file included using include
# directive in parent file.
my $isinclude = 0;
if( $ARGV[0] eq '-include' )
{	
	$isinclude = 1;
	shift @ARGV;
}

# Stores the relative path of the Makefile.am file with respect to 
# current working directory
$Tree::basedir = File::Basename::dirname($ARGV[0]);

# To enable debug mode, use 1 . Prints the parser stack at each 
# iteration
my $debug = 0;

# Stores the list of tokens generated by lexer.
my @tokens; 

my @stack = (0);
print STDERR "Parser Output\n" if $debug;

my $multiline = 0;
my $curr_tokens;

while ( @stack )
{
	if($stack[-1] == $ParserTable::accept)
	{
		if($isinclude)
		{
			# Dump the tree to standard output.
			print Dumper( $stack[-4] );
		}
		else
		{
			print STDERR "Complete\n";
			printgraph( $stack[-4] );
			recursesubdirs( $stack[-4] );
		}
		last;
	}
	while( !@tokens )
	{
		# Calls lexer to get next tokens.
		( $curr_tokens, $multiline ) = lex( $multiline );
		
		# Continue if their is no tokens
		next unless $curr_tokens;
		
		push @tokens, @$curr_tokens;
	}
	my @curr_token = @{ $tokens[0] };	
	if(my $val = $ParserTable::table[ $stack[-1] ]{ $curr_token[0] })
	{
		push @stack, \@curr_token, $val;
		shift @tokens;
	}
	elsif(my $val = $ParserTable::table[ $stack[-1] ]{ reduce })
	{
		my @val1 = @$val;
		my @param;
		for(my $i = 1; $i <= 2 * $val1[0]; $i++)
		{
			if($i%2 == 0)
			{
				$val = pop @stack;
				push @param,$val;
			}
			else
			{
				pop @stack;
			}
		}
		@param = reverse @param;
		push @stack, $val1[1]->( @param );
		push @stack, $ParserTable::table[ $stack[-2] ]{ $stack[-1]->{ name }};
	}
	else
	{
		die "Unexpected Token ". $curr_token[1]."\n";
	}
	print STDERR @stack, "\n" if $debug;
}